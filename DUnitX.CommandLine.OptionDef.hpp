// CodeGear C++Builder
// Copyright (c) 1995, 2014 by Embarcadero Technologies, Inc.
// All rights reserved

// (DO NOT EDIT: machine generated header) 'DUnitX.CommandLine.OptionDef.pas' rev: 28.00 (Windows)

#ifndef Dunitx_Commandline_OptiondefHPP
#define Dunitx_Commandline_OptiondefHPP

#pragma delphiheader begin
#pragma option push
#pragma option -w-      // All warnings off
#pragma option -Vx      // Zero-length empty class member 
#pragma pack(push,8)
#include <System.hpp>	// Pascal unit
#include <SysInit.hpp>	// Pascal unit
#include <System.Classes.hpp>	// Pascal unit
#include <System.SysUtils.hpp>	// Pascal unit
#include <System.Rtti.hpp>	// Pascal unit
#include <System.TypInfo.hpp>	// Pascal unit
#include <System.Generics.Collections.hpp>	// Pascal unit
#include <DUnitX.CommandLine.Options.hpp>	// Pascal unit

//-- user supplied -----------------------------------------------------------

namespace Dunitx
{
namespace Commandline
{
namespace Optiondef
{
//-- type declarations -------------------------------------------------------
__interface IOptionDefInvoke;
typedef System::DelphiInterface<IOptionDefInvoke> _di_IOptionDefInvoke;
__interface  INTERFACE_UUID("{580B5B40-CD7B-41B8-AE53-2C6890141FF0}") IOptionDefInvoke  : public System::IInterface 
{
	
public:
	virtual void __fastcall Invoke(const System::UnicodeString value) = 0 ;
	virtual bool __fastcall WasFound(void) = 0 ;
	virtual System::Typinfo::PTypeInfo __fastcall GetTypeInfo(void) = 0 ;
};

template<typename T> class DELPHICLASS TOptionDefinition__1;
#pragma pack(push,4)
// Template declaration generated by Delphi parameterized types is
// used only for accessing Delphi variables and fields.
// Don't instantiate with new type parameters in user code.
template<typename T> class PASCALIMPLEMENTATION TOptionDefinition__1 : public System::TInterfacedObject
{
	typedef System::TInterfacedObject inherited;
	
private:
	System::UnicodeString FLongName;
	System::UnicodeString FShortName;
	System::UnicodeString FHelpText;
	bool FHasValue;
	bool FRequired;
	bool FValueRequired;
	bool FIsOptionFile;
	bool FAllowMultiple;
	System::DelphiInterface<System::Sysutils::TProc__1<T> > FProc;
	bool FWasFound;
	System::Typinfo::TTypeInfo *FTypeInfo;
	T FDefault;
	bool FHidden;
	
protected:
	bool __fastcall GetAllowMultiple(void);
	bool __fastcall GetHasValue(void);
	System::UnicodeString __fastcall GetHelpText(void);
	System::UnicodeString __fastcall GetLongName(void);
	bool __fastcall GetRequired(void);
	System::UnicodeString __fastcall GetShortName(void);
	bool __fastcall GetValueRequired(void);
	bool __fastcall GetIsOptionFile(void);
	bool __fastcall GetIsUnnamed(void);
	bool __fastcall GetIsHidden(void);
	void __fastcall SetIsHidden(const bool value);
	void __fastcall SetIsOptionFile(const bool value);
	void __fastcall SetAllowMultiple(const bool value);
	void __fastcall SetHasValue(const bool value);
	void __fastcall SetHelpText(const System::UnicodeString value);
	void __fastcall SetLongName(const System::UnicodeString value);
	void __fastcall SetRequired(const bool value);
	void __fastcall SetShortName(const System::UnicodeString value);
	void __fastcall SetValueRequired(const bool value);
	void __fastcall Invoke(const System::UnicodeString value);
	bool __fastcall WasFound(void);
	System::Typinfo::PTypeInfo __fastcall GetTypeInfo(void);
	void __fastcall InitDefault(void);
	
public:
	__fastcall TOptionDefinition__1(const System::UnicodeString longName, const System::UnicodeString shortName, const System::DelphiInterface<System::Sysutils::TProc__1<T> > proc)/* overload */;
	__fastcall TOptionDefinition__1(const System::UnicodeString longName, const System::UnicodeString shortName, const System::UnicodeString helpText, const System::DelphiInterface<System::Sysutils::TProc__1<T> > proc)/* overload */;
public:
	/* TObject.Destroy */ inline __fastcall virtual ~TOptionDefinition__1(void) { }
	
private:
	void *__IOptionDefInvoke;	// IOptionDefInvoke 
	void *__IOptionDefintion;	// Dunitx::Commandline::Options::IOptionDefintion 
	
public:
	#if defined(MANAGED_INTERFACE_OPERATORS)
	// {580B5B40-CD7B-41B8-AE53-2C6890141FF0}
	operator _di_IOptionDefInvoke()
	{
		_di_IOptionDefInvoke intf;
		GetInterface(intf);
		return intf;
	}
	#else
	operator IOptionDefInvoke*(void) { return (IOptionDefInvoke*)&__IOptionDefInvoke; }
	#endif
	#if defined(MANAGED_INTERFACE_OPERATORS)
	// {1EAA06BA-8FBF-43F8-86D7-9F5DE26C4E86}
	operator Dunitx::Commandline::Options::_di_IOptionDefintion()
	{
		Dunitx::Commandline::Options::_di_IOptionDefintion intf;
		GetInterface(intf);
		return intf;
	}
	#else
	operator Dunitx::Commandline::Options::IOptionDefintion*(void) { return (Dunitx::Commandline::Options::IOptionDefintion*)&__IOptionDefintion; }
	#endif
	
};

#pragma pack(pop)

typedef System::StaticArray<System::UnicodeString, 11> Dunitx_Commandline_Optiondef__2;

typedef System::StaticArray<System::UnicodeString, 9> Dunitx_Commandline_Optiondef__3;

//-- var, const, procedure ---------------------------------------------------
extern DELPHI_PACKAGE Dunitx_Commandline_Optiondef__2 trueStrings;
extern DELPHI_PACKAGE Dunitx_Commandline_Optiondef__3 falseStrings;
extern DELPHI_PACKAGE bool __fastcall StringToBoolean(const System::UnicodeString value);
}	/* namespace Optiondef */
}	/* namespace Commandline */
}	/* namespace Dunitx */
#if !defined(DELPHIHEADER_NO_IMPLICIT_NAMESPACE_USE) && !defined(NO_USING_NAMESPACE_DUNITX_COMMANDLINE_OPTIONDEF)
using namespace Dunitx::Commandline::Optiondef;
#endif
#if !defined(DELPHIHEADER_NO_IMPLICIT_NAMESPACE_USE) && !defined(NO_USING_NAMESPACE_DUNITX_COMMANDLINE)
using namespace Dunitx::Commandline;
#endif
#if !defined(DELPHIHEADER_NO_IMPLICIT_NAMESPACE_USE) && !defined(NO_USING_NAMESPACE_DUNITX)
using namespace Dunitx;
#endif
#pragma pack(pop)
#pragma option pop

#pragma delphiheader end.
//-- end unit ----------------------------------------------------------------
#endif	// Dunitx_Commandline_OptiondefHPP
