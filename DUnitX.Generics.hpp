// CodeGear C++Builder
// Copyright (c) 1995, 2014 by Embarcadero Technologies, Inc.
// All rights reserved

// (DO NOT EDIT: machine generated header) 'DUnitX.Generics.pas' rev: 28.00 (Windows)

#ifndef Dunitx_GenericsHPP
#define Dunitx_GenericsHPP

#pragma delphiheader begin
#pragma option push
#pragma option -w-      // All warnings off
#pragma option -Vx      // Zero-length empty class member 
#pragma pack(push,8)
#include <System.hpp>	// Pascal unit
#include <SysInit.hpp>	// Pascal unit
#include <System.Generics.Defaults.hpp>	// Pascal unit
#include <System.Generics.Collections.hpp>	// Pascal unit
#include <System.SysUtils.hpp>	// Pascal unit
#include <System.Types.hpp>	// Pascal unit

//-- user supplied -----------------------------------------------------------

namespace Dunitx
{
namespace Generics
{
//-- type declarations -------------------------------------------------------
template<typename T> __interface IReadOnlyList__1;
// template<typename T> typedef System::DelphiInterface<IReadOnlyList__1<T> > _di_IReadOnlyList__1;
// Template declaration generated by Delphi parameterized types is
// used only for accessing Delphi variables and fields.
// Don't instantiate with new type parameters in user code.
template<typename T> __interface IReadOnlyList__1  : public System::IEnumerable__1<T> 
{
	
public:
	T operator[](int Index) { return Items[Index]; }
	
public:
	virtual int __fastcall GetCapacity(void) = 0 ;
	virtual int __fastcall GetCount(void) = 0 ;
	virtual T __fastcall GetItem(int index) = 0 ;
	typedef void __fastcall (__closure *_dt_Dunitx_Generics_1)(System::TObject* Sender, T Item, System::Generics::Collections::TCollectionNotification Action);
	virtual _dt_Dunitx_Generics_1 __fastcall GetOnNotify(void) = 0 ;
	typedef void __fastcall (__closure *_dt_Dunitx_Generics_2)(System::TObject* Sender, T Item, System::Generics::Collections::TCollectionNotification Action);
	virtual void __fastcall SetOnNotify(_dt_Dunitx_Generics_2 value) = 0 ;
	virtual T __fastcall First(void) = 0 ;
	virtual T __fastcall Last(void) = 0 ;
	virtual bool __fastcall Contains(const T Value) = 0 ;
	virtual int __fastcall IndexOf(const T Value) = 0 ;
	virtual int __fastcall LastIndexOf(const T Value) = 0 ;
	virtual bool __fastcall BinarySearch(const T Item, /* out */ int &Index) = 0 /* overload */;
	virtual bool __fastcall BinarySearch(const T Item, /* out */ int &Index, const System::DelphiInterface<System::Generics::Defaults::IComparer__1<T> > AComparer) = 0 /* overload */;
	__property int Capacity = {read=GetCapacity};
	__property int Count = {read=GetCount};
	__property T Items[int Index] = {read=GetItem/*, default*/};
	typedef void __fastcall (__closure *_dt_Dunitx_Generics_3)(System::TObject* Sender, T Item, System::Generics::Collections::TCollectionNotification Action);
	__property _dt_Dunitx_Generics_3 OnNotify = {read=GetOnNotify, write=SetOnNotify};
};

template<typename T> __interface IList__1;
// template<typename T> typedef System::DelphiInterface<IList__1<T> > _di_IList__1;
// Template declaration generated by Delphi parameterized types is
// used only for accessing Delphi variables and fields.
// Don't instantiate with new type parameters in user code.
template<typename T> __interface IList__1  : public IReadOnlyList__1<T> 
{
	
public:
	T operator[](int Index) { return Items[Index]; }
	
public:
	virtual void __fastcall SetCapacity(const int value) = 0 ;
	virtual void __fastcall SetCount(const int value) = 0 ;
	virtual void __fastcall SetItem(int index, T value) = 0 ;
	virtual int __fastcall Add(const T Value) = 0 ;
	virtual void __fastcall AddRange(T const *Values, const int Values_High) = 0 /* overload */;
	virtual void __fastcall AddRange(const System::DelphiInterface<System::IEnumerable__1<T> > Collection) = 0 /* overload */;
	virtual void __fastcall AddRange(System::Generics::Collections::TEnumerable__1<T>* Collection) = 0 /* overload */;
	virtual void __fastcall Insert(int Index, const T Value) = 0 ;
	virtual void __fastcall InsertRange(int Index, T const *Values, const int Values_High) = 0 /* overload */;
	virtual void __fastcall InsertRange(int Index, const System::DelphiInterface<System::IEnumerable__1<T> > Collection) = 0 /* overload */;
	virtual void __fastcall InsertRange(int Index, System::Generics::Collections::TEnumerable__1<T>* const Collection) = 0 /* overload */;
	virtual int __fastcall Remove(const T Value) = 0 ;
	virtual void __fastcall Delete(int Index) = 0 ;
	virtual void __fastcall DeleteRange(int AIndex, int ACount) = 0 ;
	virtual T __fastcall Extract(const T Value) = 0 ;
	virtual void __fastcall Exchange(int Index1, int Index2) = 0 ;
	virtual void __fastcall Move(int CurIndex, int NewIndex) = 0 ;
	virtual void __fastcall Clear(void) = 0 ;
	virtual void __fastcall Reverse(void) = 0 ;
	virtual void __fastcall Sort(void) = 0 /* overload */;
	virtual void __fastcall Sort(const System::DelphiInterface<System::Generics::Defaults::IComparer__1<T> > AComparer) = 0 /* overload */;
	virtual void __fastcall TrimExcess(void) = 0 ;
	virtual System::DynamicArray<T> __fastcall ToArray(void) = 0 ;
	__property int Capacity = {read=GetCapacity, write=SetCapacity};
	__property int Count = {read=GetCount, write=SetCount};
	__property T Items[int Index] = {read=GetItem, write=SetItem/*, default*/};
	typedef void __fastcall (__closure *_dt_Dunitx_Generics_4)(System::TObject* Sender, T Item, System::Generics::Collections::TCollectionNotification Action);
	__property _dt_Dunitx_Generics_4 OnNotify = {read=GetOnNotify, write=SetOnNotify};
};

class DELPHICLASS TDUnitXEnumerable;
#pragma pack(push,4)
class PASCALIMPLEMENTATION TDUnitXEnumerable : public System::TInterfacedObject
{
	typedef System::TInterfacedObject inherited;
	
protected:
	virtual System::_di_IEnumerator __fastcall GetNonGenEnumerator(void) = 0 ;
public:
	/* TObject.Create */ inline __fastcall TDUnitXEnumerable(void) : System::TInterfacedObject() { }
	/* TObject.Destroy */ inline __fastcall virtual ~TDUnitXEnumerable(void) { }
	
private:
	void *__IEnumerable;	// System::IEnumerable 
	
public:
	operator System::IEnumerable*(void) { return (System::IEnumerable*)&__IEnumerable; }
	
};

#pragma pack(pop)

template<typename T> class DELPHICLASS TDUnitXList__1;
#pragma pack(push,4)
// Template declaration generated by Delphi parameterized types is
// used only for accessing Delphi variables and fields.
// Don't instantiate with new type parameters in user code.
template<typename T> class PASCALIMPLEMENTATION TDUnitXList__1 : public TDUnitXEnumerable
{
	typedef TDUnitXEnumerable inherited;
	
private:
	System::Generics::Collections::TList__1<T>* FList;
	
protected:
	System::DelphiInterface<System::IEnumerator__1<T> > __fastcall GetEnumerator(void)/* overload */;
	virtual System::_di_IEnumerator __fastcall GetNonGenEnumerator(void);
	int __fastcall GetCapacity(void);
	void __fastcall SetCapacity(const int value);
	int __fastcall GetCount(void);
	void __fastcall SetCount(const int value);
	T __fastcall GetItem(int index);
	void __fastcall SetItem(int index, T value);
	typedef void __fastcall (__closure *_dt_Dunitx_Generics_5)(System::TObject* Sender, T Item, System::Generics::Collections::TCollectionNotification Action);
	_dt_Dunitx_Generics_5 __fastcall GetOnNotify(void);
	typedef void __fastcall (__closure *_dt_Dunitx_Generics_6)(System::TObject* Sender, T Item, System::Generics::Collections::TCollectionNotification Action);
	void __fastcall SetOnNotify(_dt_Dunitx_Generics_6 value);
	int __fastcall Add(const T Value);
	void __fastcall AddRange(T const *Values, const int Values_High)/* overload */;
	void __fastcall AddRange(const System::DelphiInterface<System::IEnumerable__1<T> > Collection)/* overload */;
	void __fastcall AddRange(System::Generics::Collections::TEnumerable__1<T>* Collection)/* overload */;
	void __fastcall Insert(int Index, const T Value);
	void __fastcall InsertRange(int Index, T const *Values, const int Values_High)/* overload */;
	void __fastcall InsertRange(int Index, const System::DelphiInterface<System::IEnumerable__1<T> > Collection)/* overload */;
	void __fastcall InsertRange(int Index, System::Generics::Collections::TEnumerable__1<T>* const Collection)/* overload */;
	int __fastcall Remove(const T Value);
	void __fastcall Delete(int Index);
	void __fastcall DeleteRange(int AIndex, int ACount);
	T __fastcall Extract(const T Value);
	void __fastcall Exchange(int Index1, int Index2);
	void __fastcall Move(int CurIndex, int NewIndex);
	T __fastcall First(void);
	T __fastcall Last(void);
	void __fastcall Clear(void);
	bool __fastcall Contains(const T Value);
	int __fastcall IndexOf(const T Value);
	int __fastcall LastIndexOf(const T Value);
	void __fastcall Reverse(void);
	void __fastcall Sort(void)/* overload */;
	void __fastcall Sort(const System::DelphiInterface<System::Generics::Defaults::IComparer__1<T> > AComparer)/* overload */;
	bool __fastcall BinarySearch(const T Item, /* out */ int &Index)/* overload */;
	bool __fastcall BinarySearch(const T Item, /* out */ int &Index, const System::DelphiInterface<System::Generics::Defaults::IComparer__1<T> > AComparer)/* overload */;
	void __fastcall TrimExcess(void);
	System::DynamicArray<T> __fastcall ToArray(void);
	
public:
	__fastcall TDUnitXList__1(void)/* overload */;
	__fastcall TDUnitXList__1(const System::DelphiInterface<System::Generics::Defaults::IComparer__1<T> > AComparer)/* overload */;
	__fastcall TDUnitXList__1(System::Generics::Collections::TEnumerable__1<T>* Collection)/* overload */;
	__fastcall virtual ~TDUnitXList__1(void);
private:
	void *__IList__1;	// IList__1<T> 
	
public:
	operator System::IEnumerable__1<T>*(void) { return (System::IEnumerable__1<T>*)&__IList__1; }
	operator IList__1<T>*(void) { return (IList__1<T>*)&__IList__1; }
	
};

#pragma pack(pop)

template<typename T> class DELPHICLASS TDUnitXIEnumerator__1;
#pragma pack(push,4)
// Template declaration generated by Delphi parameterized types is
// used only for accessing Delphi variables and fields.
// Don't instantiate with new type parameters in user code.
template<typename T> class PASCALIMPLEMENTATION TDUnitXIEnumerator__1 : public System::TInterfacedObject
{
	typedef System::TInterfacedObject inherited;
	
private:
	System::DelphiInterface<IList__1<T> > FList;
	int FIndex;
	
protected:
	T __fastcall GetCurrentGen(void);
	System::TObject* __fastcall GetCurrent(void);
	bool __fastcall MoveNext(void);
	void __fastcall Reset(void);
	
public:
	__fastcall TDUnitXIEnumerator__1(const System::DelphiInterface<IList__1<T> > AList);
public:
	/* TObject.Destroy */ inline __fastcall virtual ~TDUnitXIEnumerator__1(void) { }
	
private:
	void *__IEnumerator;	// System::IEnumerator 
	void *__IEnumerator__1;	// System::IEnumerator__1<T> 
	
public:
	operator System::IEnumerator*(void) { return (System::IEnumerator*)&__IEnumerator; }
	operator System::IEnumerator__1<T>*(void) { return (System::IEnumerator__1<T>*)&__IEnumerator__1; }
	
};

#pragma pack(pop)

//-- var, const, procedure ---------------------------------------------------
}	/* namespace Generics */
}	/* namespace Dunitx */
#if !defined(DELPHIHEADER_NO_IMPLICIT_NAMESPACE_USE) && !defined(NO_USING_NAMESPACE_DUNITX_GENERICS)
using namespace Dunitx::Generics;
#endif
#if !defined(DELPHIHEADER_NO_IMPLICIT_NAMESPACE_USE) && !defined(NO_USING_NAMESPACE_DUNITX)
using namespace Dunitx;
#endif
#pragma pack(pop)
#pragma option pop

#pragma delphiheader end.
//-- end unit ----------------------------------------------------------------
#endif	// Dunitx_GenericsHPP
